package swax.webservice.serviceImpl.home;
import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.List;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import swax.webservice.dto.LatestAdditionDTO;import swax.webservice.dto.PossibleSwapDTO;import swax.webservice.entity.album.AlbumWantlist;import swax.webservice.entity.album.SwapAlbum;import swax.webservice.entity.album.comparator.SwapAlbumComparator;import swax.webservice.entity.user.User;import swax.webservice.service.album.ISwapAlbumService;import swax.webservice.service.home.IHomeService;import swax.webservice.service.user.IUserService;/** *  * @author Matthieu Ibarra * */
@Service("homeService")public class HomeServiceImpl implements IHomeService {		static int LAST_ADD_NUMBER = 6;		@Autowired	private ISwapAlbumService swapAlbumService = null;		@Autowired	private IUserService userService = null;	/**	 * Initialize the home page to display the last 6 albums proposed for swapping	 * @param User	 * @return a collection of LatestAdditionDTO	 */	@Override	public Collection<LatestAdditionDTO> initHome(User user) {				List<LatestAdditionDTO> result = new ArrayList<>();		Comparator<SwapAlbum> comparator = new SwapAlbumComparator();		List<SwapAlbum> swapAlbums;				try {						swapAlbums = swapAlbumService.findAll();			Collections.sort(swapAlbums, comparator.reversed());						int count = 1;			int index = 0;			while (count  <= LAST_ADD_NUMBER) {				if ((swapAlbums.get(index).isAlbumToSwap()==true) && !(swapAlbums.get(index).getUser().getUserId() == user.getUserId())) {					count++;					LatestAdditionDTO latestAddition = new LatestAdditionDTO(swapAlbums.get(index));					result.add(latestAddition);				}				index++;					}		} catch (Exception e) {			return null;		}		return result;	}		/**	 * Finds possible swaps for the User	 * @param User	 * @return List of PossibleSwapDTO	 */	@Override	public List<PossibleSwapDTO> initPossibleSwaps(User user) {		List<PossibleSwapDTO> possibleSwaps = this.swapAlbumService.findPossibleSwapsByUser(user.getUserId());		return possibleSwaps;	}		/**	 * Find if the user connected has albums to swap with users who have albums in his wantlist	 * @param List<PossibleSwapDTO>, List<SwapAlbum>	 * @return Map of User and list of SwapAlbum	 */	@Override	public Map<User, List<SwapAlbum>> initPerfectSwaps(List<PossibleSwapDTO> possibleSwaps, List<SwapAlbum> albumsToSwap) {		List<User> usersToSwapWith = new ArrayList<User>();		Map<User, List<SwapAlbum>> perfectMatchesMap = new HashMap<User, List<SwapAlbum>>();				// Get the users who have albums the user connected wants		for (PossibleSwapDTO possibleSwap: possibleSwaps) {			User user = userService.findByUserId(possibleSwap.getUserId());			if (!usersToSwapWith.contains(user)) {				usersToSwapWith.add(user);			}		}				// Find if the user connected has albums other users want		for (User user: usersToSwapWith) {			List<AlbumWantlist> userWantlist = user.getWantlist();			List<SwapAlbum> perfectMatches = new ArrayList<SwapAlbum>();			for (SwapAlbum swapAlbum: albumsToSwap) {				if (swapAlbum.isAlbumToSwap()) {					for (AlbumWantlist albumWantlist: userWantlist) {						if (albumWantlist.getAlbum().getDiscogsId()==swapAlbum.getAlbum().getDiscogsId()) {							perfectMatches.add(swapAlbum);						}					}				}			}			if (!perfectMatches.isEmpty()) {				perfectMatchesMap.put(user, perfectMatches);			}		}				return perfectMatchesMap;	}		
}